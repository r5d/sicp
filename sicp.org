* notes
** 1
*** 1
**** 5
#+BEGIN_QUOTE
In general, when modeling phenomena in science and engineering, we
begin with simplified, incomplete models. As we examine things in
greater detail, these simple models become inadequate and must be
replaced by more refined models.
#+END_QUOTE
* exercises
** 1
*** 4

    #+BEGIN_SRC scheme
    (define (a-plus-abs-b a b)
      ((if (> b 0) + -) a b))
    #+END_SRC

If ~b~ is greater than 0, do ~a + b~; otherwise do ~a - b~.
*** 5

code at [[./one/five.scm]]

If the interpreter uses *applicative order* to evaluate the
expression:

#+BEGIN_SRC scheme
(test 0 (p))
#+END_SRC

The parameters are evaluated before applying the compound procedure
~test~; 0 evaluates to 0, ~(p)~ never finishes evaluating as the
compound procedure ~p~ recursively calls itself again and again
infinitely.

If same expression is evaluated by the interpreter using *normal
order*, the expression will be expanded to

#+BEGIN_SRC scheme
  (if (= 0 0)
      0
      (p)))
#+END_SRC

and will evaluate to ~0~.
*** 6
    If I've understood it correctly, scheme uses applicative-order
    evaluation, meaning, it evaluates the operands before appling the
    procedure.

    In the case when ~new-if~ used in the ~sqrt-iter~ procedure, the
    operands/arguments for the ~new-if~ -- ~(good-enough? guess x)~,
    ~guess~, ~(sqrt-iter (improve guess x) x)~ -- are evaluated. Due
    to the last operand, which is a call to the ~sqrt-iter~ procedure,
    we get into infinite loop of evaluating the ~sqrt-iter~ procedure
    again and again.
